
# coding: utf-8

# In[3]:

import numpy as np
x = np.array([1, 2, 3])
x.dtype


# In[4]:

np.exp(-np.inf)


# In[5]:

np.array([1, 0]) / np.array([0, 0])


# In[6]:

x = np.array([1, 2, 3])
x


# In[7]:

a = np.zeros(5) 
a
#0인 5개의 배열을 만듬


# In[8]:

b = np.zeros((5,2), dtype="f8")
b
#


# In[9]:

c = np.zeros(5, dtype="S4")
c[0] = "abcd"
c[1] = "ABCDE"
c


# In[11]:

c = np.zeros(5, dtype="S4")
c


# In[12]:

c[0]


# In[14]:

c[0] = "abcd"
c[0]
#c[0]에 abcd삽입


# In[15]:

c[1] = "ABCDE"
c[1]


# In[16]:

d = np.ones((2,3,4), dtype="i8")
d
#1로 초기화된 배열


# In[18]:

e = range(10)
print(e)
f = np.ones_like(e, dtype="f")
f
#만약 크기를 튜플(tuple)로 명시하지 않고 특정한 배열 
#혹은 리스트와 같은 크기의 배열을 생성하고 싶다면 ones_like, zeros_like 명령을 사용한다.


# In[19]:

e


# In[21]:

#배열의 크기가 커지면 배열을 초기화하는데도 시간이 걸린다. 
#이 시간을 단축하려면 생성만 하고 초기화를 하지 않는 empty 명령을 사용할 수 있다. 
#empty 명령으로 생성된 배열에 어떤 값이 들어있을지는 알 수 없다.



# In[58]:

b = np.empty((4,3))
b


# In[60]:

#arange 명령은 NumPy 버전의 range 명령이라고 볼 수 있다. 특정한 규칙에 따라 증가하는 수열을 만든다.


# In[61]:

np.arange(10)  # 0 .. n-1  


# In[62]:

np.arange(3, 21, 2)  # 시작, 끝(포함하지 않음), 단계


# In[63]:

#linspace 명령이나 logspace 명령은 선형 구간 혹은 로그 구간을 지정한 구간의 수만큼 분할한다.


# In[64]:

np.linspace(0, 100, 5)  # 시작, 끝(포함), 갯수


# In[71]:

np.logspace(0, 3, 5, endpoint=False)
#2. logspace(X1, X2, n)
#X1, X2, n 을 Log Scale적으로 등간격인 행벡터를 생성한다.
#10^X1 과 10^X2 사이에 등간격인 n개의 행벡터를 만들어 낸다.
#n이 생략되고 logspace(X1, X2) 명령을 수행하면
#50개의 벡터를 등간격으로 생성한다.
 


# In[ ]:

#임의의 난수를 생성하고 싶다면 random 서브패키지의 rand 혹은 randn 명령을 사용한다.
#rand 명령을 uniform 분포를 따르는 난수를 생성하고 randn 명령은 가우시안 정규 분포를 
#따르는 난수를 생성한다. 생성할 시드(seed)값을 지정하려면 seed 명령을 사용한다.


# In[75]:

np.random.seed(0)


# In[73]:

np.random.rand(4)


# In[76]:

np.random.randn(3,5)
#가우시안 정규 분포를 따르는 난수 5개를 3리스트 만듬


# In[80]:

A = np.array([[1, 2, 3], [4, 5, 6]])
A


# In[81]:

A.T


# In[ ]:

#배열의 크기 변형
#일단 만들어진 배열의 내부 데이터는 보존한 채로 형태만 바꾸려면
#reshape 명령이나 메서드를 사용한다. 
#예를 들어 12개의 원소를 가진 1차원 행렬은 
#3x4 형태의 2차원 행렬로 만들 수 있다.


# In[82]:

a = np.arange(12)
a


# In[83]:

b = a.reshape(3, 4)
b


# In[ ]:

#사용하는 원소의 갯수가 정해저 있기 때문에 
#reshape 명령의 형태 튜플의 원소 중 하나는 -1이라는 숫자로 대체할 수 있다.
#-1을 넣으면 해당 숫자는 다를 값에서 계산되어 사용된다.


# In[90]:

a.reshape(2,3,-1)
#-1넣은 자리는 자동계산


# In[94]:

a.reshape(2,-1,2)


# In[95]:

a.flatten()#다시 펼침


# In[96]:

#배열 사용에서 주의할 점은 길이가 5인 1차원 배열과 행, 열의 갯수가 (5,1)인 2차원 배열 또는 행, 열의 갯수가 (1, 5)인 2차원 배열은 데이터가 같아도 엄연히 다른 객체라는 점이다.


# In[97]:

x = np.arange(5)
x


# In[98]:

x.reshape(1,5)


# In[99]:


x.reshape(5,1)


# In[100]:

x[:, np.newaxis]


# In[101]:

x


# In[ ]:

#hstack 명령은 행의 수가 같은 두 개 이상의 배열을 옆으로 연결하여 
#열의 수가 더 많은 배열을 만든다. 연결할 배열은 하나의 리스트에 담아야 한다.


# In[102]:

a1 = np.ones((2, 3))
a1


# In[103]:

a2 = np.zeros((2, 2))
a2


# In[104]:

np.hstack([a1, a2])


# In[ ]:

#vstack 명령은 열의 수가 같은 두 개 이상의 배열을 위아래로 
#연결하여 행의 수가 더 많은 배열을 만든다. 
#연결할 배열은 마찬가지로 하나의 리스트에 담아야 한다.


# In[105]:

b1 = np.ones((2, 3))
b1


# In[106]:

b2 = np.zeros((3, 3))
b2


# In[107]:

np.vstack([b1, b2])


# In[108]:

np.vstack([b1, b2])


# In[109]:

#dstack 명령은 제3의 축 즉, 행이나 열이 아닌 깊이(depth) 방향으로 배열을 합친다.
#가장 안쪽의 원소의 차원이 증가한다. 즉 가장 내부의 숫자 원소가 배열이 된다. 
#shape 정보로 보자면 가장 끝에 값이 2인 차원이 추가되는 것이다.
#이 예제의 경우에는 shape 변화가 2개의 (3 x 4) -> 1개의 (3 x 4 x 2)가 된다.


# In[110]:

c1 = np.ones((3,4))
c1


# In[111]:

c2 = np.zeros((3,4))
c2


# In[112]:

np.dstack([c1, c2])


# In[113]:

(np.dstack([c1, c2])).shape


# In[ ]:

#stack 명령은 지정한 차원(축으로) 배열을 연결한다. axis 인수(디폴트 0)를 사용하여 연결후의 회전 방향을 정한다. 
#디폴트 인수값은 0이고 가장 앞쪽에 차원이 생성된다. 
#즉, 배열 두 개가 겹치게 되므로 연결하고자 하는 배열들의 크기가 모두 같아야 한다.
#다음 예에서는 axis=0 이므로 가장 값에 값이 2인 차원이 추가된다. 
#즉, shape 변화는 2개의 (3 x 4) -> 1개의 (2 x 3 x 4) 이다..


# In[126]:

c = np.stack([c1, c2], axis=1)
c


# In[116]:

c.shape


# In[ ]:

# r_ 메서드는 hstack 명령과 비슷하게 배열을 좌우로 연결한다. 
#다만 메서드임에도 불구하고 소괄호(parenthesis, ())를 사용하지
#않고 인덱싱과 같이 대괄호(bracket, [])를 사용한다. 이런 특수 메서드를 인덱서(indexer)라고 한다


# In[127]:


np.r_[np.array([1,2,3]), np.array([4,5,6])]


# In[128]:

#c_ 메서드는 배열의 차원을 증가시킨 후 좌우로 연결한다. 만약 1차원 배열을 연결하면 2차원 배열이 된다.


# In[130]:

np.c_[np.array([1,2,3]), np.array([4,5,6])]


# In[131]:

#tile 명령은 동일한 배열을 반복하여 연결한다.


# In[135]:

a = np.array([0, 1, 2])
a


# In[ ]:




# In[134]:

b=np.tile(a, 2)
b


# In[136]:

np.tile(a, (3, 2))


# In[ ]:

#그리드 생성
#변수가 2개인 2차원 함수의 그래프를 그리거나 표를 작성하려면 많은 좌표를 한꺼번에 생성하여 
#각 좌표에 대한 함수 값을 계산해야 한다. 예를 들어 x, y 라는 두 변수를 가진 함수에서 x가 0부터 2까지, 
#y가 0부터 4까지의 사각형 영역에서 변화하는 과정을 보고 싶다면 이 사각형 영역 안의 
#다음과 같은 (x,y) 쌍 값들에 대해 함수를 계산해야 한다.

#(x,y)=(0,0),(0,1),(0,2),(0,3),(0,4),(1,0),⋯(2,4)
#(x,y)=(0,0),(0,1),(0,2),(0,3),(0,4),(1,0),⋯(2,4)
 
#이러한 과정을 자동으로 해주는 것이 NumPy의 meshgrid 명령이다. 
#meshgrid 명령은 사각형 영역을 구성하는 가로축의 점들과 세로축의 점을 나타내는 
#두 벡터를 인수로 받아서 이 사각형 영역을 이루는 조합을 출력한다.
#단 조합이 된 (x,y)쌍을 x값만을 표시하는 행렬과 y값만을 표시하는 행렬 두 개로 분리하여 출력한다.


# In[137]:

x = np.arange(3)
x


# In[138]:

y = np.arange(5)
y


# In[139]:

X, Y = np.meshgrid(x, y)


# In[140]:

X


# In[142]:

Y


# In[143]:

[zip(x, y) for x, y in zip(X, Y)]


# In[144]:

plt.scatter(X, Y, linewidths=10)
plt.show()


# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:



