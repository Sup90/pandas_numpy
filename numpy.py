
# coding: utf-8

# In[2]:

import numpy as np 


# In[3]:

a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
a


# In[5]:

type(a)


# In[6]:

numpy.ndarray 


# In[7]:

a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


# In[8]:

ㅁ


# In[9]:

a


# In[10]:

b = []
for ai in a:
    b.append(ai * 2)
b    


# In[11]:

x = np.array(a)
x


# In[12]:

x * 2


# In[13]:

L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(2 * L)


# In[14]:

a = np.array([1, 2, 3])
b = np.array([10, 20, 30])


# In[16]:

c=2 * a + b


# In[17]:

c


# In[18]:

np.exp(a)


# In[19]:

np.sin(a)


# In[21]:

b = np.array([[0, 1, 2], [3, 4, 5]])  # 2 x 3 array
b


# In[22]:

len(b)


# In[23]:

len(b[0])


# In[24]:

#연습문제1


# In[ ]:

a=np.array([10,20,30,40],[50,60,70,80])


# In[25]:

c = np.array([[[1,2,3,4],[5,6,7,8],[9,10,11,12]],[[11,12,13,14],[15,16,17,18],[19,20,21,22]]])   # 2 x 3 x 4 array
c


# In[26]:

len(c)#첫번째 리스트 길이


# In[28]:

len(c[0])#두번째 리스트 길이


# In[29]:

len(c[0][0]) #세번째 리스트 길이


# In[30]:

print(a.ndim)
print(a.shape)


# In[31]:

a


# In[32]:

print(c.shape)#차원의 크키 


# In[33]:

print(c.ndim)#차원 표시


# In[34]:

a = np.array([[0, 1, 2], [3, 4, 5]])
a
#콤마를 통해 각 차원의 원소에 접근 가능함


# In[35]:

a[0,0] # 첫번째 행의 첫번째 열


# In[36]:

a[0,1] # 첫번째 행의 두번째 열


# In[37]:

a[-1, -1] # 마지막 행의 마지막 열


# In[ ]:

#배열 슬라이싱
#배열 객체로 구현한 다차원 배열의 원소 중 복수 개를 
#접근하려면 일반적인 파이썬 슬라이싱(slicing)과 comma(,)를 함께 사용하면 된다.


# In[38]:

a = np.array([[0, 1, 2, 3], [4, 5, 6, 7]])
a


# In[39]:

a[0, :]  # 첫번째 행 전체


# In[40]:

a[0,]  #위와 같은 결과


# In[41]:

a[:, 1]  # 두번째 열 전체


# In[42]:

a[1, 1:]  # 두번째 행의 두번째 열부터 끝열까지


# In[54]:

a[:2,:1] #1~2번째 리스트에서 1번째 원소만 뽑는다


# In[55]:

m = array([[ 0,  1,  2,  3,  4],
          [ 5,  6,  7,  8,  9],
         [10, 11, 12, 13, 14]])


# In[ ]:




# In[57]:

#연습문제2
m = np.array([[ 0,  1,  2,  3,  4],
          [ 5,  6,  7,  8,  9],
         [10, 11, 12, 13, 14]])
#이 행렬에서 값 7 을 인덱싱한다.
m[1,2]
#이 행렬에서 값 14 을 인덱싱한다.
m[2,4]
#이 행렬에서 배열 [6, 7] 을 슬라이싱한다.
m[1,1:3]
#이 행렬에서 배열 [7, 12] 을 슬라이싱한다.
m[1:3,2]
#이 행렬에서 배열 [[3, 4], [8, 9]] 을 슬라이싱한다.
m[:2,3:5]


# In[58]:

m[1,2]


# In[59]:

m[2,4]


# In[66]:

m[1,1:3]


# In[68]:

m[1:3,2]


# In[73]:

m[:2,3:5]


# In[75]:

#배열 인덱싱
#인덱싱이라는 이름이 붙었지만 사실은 데이터베이스의 질의(Query) 기능을 수행한다.
#배열 인덱싱에서는 대괄호(Bracket, [])안의 인덱스 정보로 숫자나 슬라이스가 아니라 
#위치 정보를 나타내는 또 다른 ndarray 배열을 받을 수 있다. 
#여기에서는 이 배열을 편의상 인덱스 배열이라고 부르겠다. 
#배열 인덱싱의 방식에은 불리안(Boolean) 배열 방식과 정수 배열 방식 두가지가 있다.

#먼저 불리안 배열 인덱싱 방식은 인덱스 배열의 원소가 True, False 
#두 값으로만 구성되며 인덱스 배열의 크기가 원래 ndarray 객체의 크기와 같아야 한다.
#예를 들어 다음과 같은 1차원 ndarray에서 홀수인 원소만 골라내려면 
#홀수인 원소에 대응하는 인덱스 값이 True이고 짝수인 원소에 대응하는 
#인덱스 값이 False인 인덱스 배열을 넣으면 된다.


# In[76]:

a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
idx = np.array([True, False, True, False, True, False, True, False, True, False])
a[idx]
#[]안이 일종의 조건문 형태가 됨


# In[77]:

idx


# In[78]:

a[a % 2 == 0]


# In[81]:

a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) * 10
idx = np.array([0, 2, 4, 6, 8])
a[idx]


# In[ ]:




# In[84]:

a = np.array([0, 1, 2, 3]) * 10
idx = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2])
a


# In[83]:

a[idx]


# In[104]:

a = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]]) 
a


# In[110]:

a[:,np.array([True,False,False,True])]


# In[98]:

c


# In[88]:

a[[2, 0, 1], :]


# In[90]:

a[:]


# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:

이 행렬에서 값 7 을 인덱싱한다.
이 행렬에서 값 14 을 인덱싱한다.
이 행렬에서 배열 [6, 7] 을 슬라이싱한다.
이 행렬에서 배열 [7, 12] 을 슬라이싱한다.
이 행렬에서 배열 [[3, 4], [8, 9]] 을 슬라이싱한다.


# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:



